/**
 * This file was auto-generated by mofcomp -j version 1.0.0 on Mon Nov 29 
 * 11:50:57 CET 2010. 
 */

package net.i2cat.mantychore.model;

import javax.wbem.client.*;
import javax.wbem.cim.*;
import java.util.*;
import java.io.*;
import java.lang.Exception;

/**
 * This Class contains accessor and mutator methods for all properties defined 
 * in the CIM class SettingData as well as methods comparable to the 
 * invokeMethods defined for this class. This Class implements the 
 * SettingDataBean Interface. The CIM class SettingData is described as 
 * follows: 
 * 
 * CIM_SettingData is used to represent configuration and and operational 
 * parameters for CIM_ManagedElement instances. There are a number of 
 * different uses of CIM_SettingData supported in the model today. Additional 
 * uses may be defined in the future. Instances of CIM_SettingData may 
 * represent Aspects of a CIM_ManagedElement instance. This is modeled using 
 * the CIM_SettingsDefineState association. CIM_SettingData may be used to 
 * define capabilities when associated to an instance of CIM_Capabilities 
 * through the CIM_SettingsDefineCapabilities association. Instances of 
 * CIM_SettingData may represent different types of configurations for a 
 * CIM_ManagedElement, including persistent configurations, in progress 
 * configuration changes, or requested configurations. The 
 * CIM_ElementSettingData association is used to model the relationship 
 * between a CIM_SettingData instance and the CIM_ManagedElement for which it 
 * is a configuration. When an instance of CIM_SettingData represents a 
 * configuration, the current operational values for the parameters of the 
 * element are reflected by properties in the Element itself or by properties 
 * in its associations. These properties do not have to be the same values 
 * that are present in the SettingData object. For example, a modem might 
 * have a SettingData baud rate of 56Kb/sec but be operating at 19.2Kb/sec. 
 * Note: The CIM_SettingData class is very similar to CIM_Setting, yet both 
 * classes are present in the model because many implementations have 
 * successfully used CIM_Setting. However, issues have arisen that could not 
 * be resolved without defining a new class. Therefore, until a new major 
 * release occurs, both classes will exist in the model. Refer to the Core 
 * White Paper for additional information. SettingData instances can be 
 * aggregated together into higher- level SettingData objects using 
 * ConcreteComponent associations. 
 */
public class SettingData extends ManagedElement implements Serializable {

    /**
     * This constructor creates a SettingDataBeanImpl Class which implements 
     * the SettingDataBean Interface, and encapsulates the CIM class 
     * SettingData in a Java Bean. The CIM class SettingData is described as 
     * follows: 
     * 
     * CIM_SettingData is used to represent configuration and and operational 
     * parameters for CIM_ManagedElement instances. There are a number of 
     * different uses of CIM_SettingData supported in the model today. 
     * Additional uses may be defined in the future. Instances of 
     * CIM_SettingData may represent Aspects of a CIM_ManagedElement 
     * instance. This is modeled using the CIM_SettingsDefineState 
     * association. CIM_SettingData may be used to define capabilities when 
     * associated to an instance of CIM_Capabilities through the 
     * CIM_SettingsDefineCapabilities association. Instances of 
     * CIM_SettingData may represent different types of configurations for a 
     * CIM_ManagedElement, including persistent configurations, in progress 
     * configuration changes, or requested configurations. The 
     * CIM_ElementSettingData association is used to model the relationship 
     * between a CIM_SettingData instance and the CIM_ManagedElement for 
     * which it is a configuration. When an instance of CIM_SettingData 
     * represents a configuration, the current operational values for the 
     * parameters of the element are reflected by properties in the Element 
     * itself or by properties in its associations. These properties do not 
     * have to be the same values that are present in the SettingData object. 
     * For example, a modem might have a SettingData baud rate of 56Kb/sec 
     * but be operating at 19.2Kb/sec. Note: The CIM_SettingData class is 
     * very similar to CIM_Setting, yet both classes are present in the model 
     * because many implementations have successfully used CIM_Setting. 
     * However, issues have arisen that could not be resolved without 
     * defining a new class. Therefore, until a new major release occurs, 
     * both classes will exist in the model. Refer to the Core White Paper 
     * for additional information. SettingData instances can be aggregated 
     * together into higher- level SettingData objects using 
     * ConcreteComponent associations. 
     */
    protected SettingData(){};
    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property InstanceID. 
     */
    private String instanceID;
    /**
     * This method returns the SettingData.InstanceID property value. This 
     * property is described as follows: 
     * 
     * Within the scope of the instantiating Namespace, InstanceID opaquely 
     * and uniquely identifies an instance of this class. To ensure 
     * uniqueness within the NameSpace, the value of InstanceID should be 
     * constructed using the following "preferred" algorithm: 
     * <OrgID>:<LocalID> Where <OrgID> and <LocalID> are separated by a colon 
     * (:), and where <OrgID> must include a copyrighted, trademarked, or 
     * otherwise unique name that is owned by the business entity that is 
     * creating or defining the InstanceID or that is a registered ID 
     * assigned to the business entity by a recognized global authority. 
     * (This requirement is similar to the <Schema Name>_<Class Name> 
     * structure of Schema class names.) In addition, to ensure uniqueness, 
     * <OrgID> must not contain a colon (:). When using this algorithm, the 
     * first colon to appear in InstanceID must appear between <OrgID> and 
     * <LocalID>. <LocalID> is chosen by the business entity and should not 
     * be reused to identify different underlying (real-world) elements. If 
     * the above "preferred" algorithm is not used, the defining entity must 
     * assure that the resulting InstanceID is not reused across any 
     * InstanceIDs produced by this or other providers for the NameSpace of 
     * this instance. For DMTF-defined instances, the "preferred" algorithm 
     * must be used with the <OrgID> set to CIM. 
     * 
     * @return	String	current InstanceID property value
     * @exception	Exception	
     */
    public String getInstanceID(){

    return (String)instanceID;
    } // getInstanceID

    /**
     * This method sets the SettingData.InstanceID property value. This 
     * property is described as follows: 
     * 
     * Within the scope of the instantiating Namespace, InstanceID opaquely 
     * and uniquely identifies an instance of this class. To ensure 
     * uniqueness within the NameSpace, the value of InstanceID should be 
     * constructed using the following "preferred" algorithm: 
     * <OrgID>:<LocalID> Where <OrgID> and <LocalID> are separated by a colon 
     * (:), and where <OrgID> must include a copyrighted, trademarked, or 
     * otherwise unique name that is owned by the business entity that is 
     * creating or defining the InstanceID or that is a registered ID 
     * assigned to the business entity by a recognized global authority. 
     * (This requirement is similar to the <Schema Name>_<Class Name> 
     * structure of Schema class names.) In addition, to ensure uniqueness, 
     * <OrgID> must not contain a colon (:). When using this algorithm, the 
     * first colon to appear in InstanceID must appear between <OrgID> and 
     * <LocalID>. <LocalID> is chosen by the business entity and should not 
     * be reused to identify different underlying (real-world) elements. If 
     * the above "preferred" algorithm is not used, the defining entity must 
     * assure that the resulting InstanceID is not reused across any 
     * InstanceIDs produced by this or other providers for the NameSpace of 
     * this instance. For DMTF-defined instances, the "preferred" algorithm 
     * must be used with the <OrgID> set to CIM. 
     * 
     * @param	String	new InstanceID property value
     * @exception	Exception	
     */
    public void setInstanceID(String instanceID) {

    this.instanceID = instanceID;
    } // setInstanceID


    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property ElementName. 
     */
    private String elementName;
    /**
     * This method returns the SettingData.ElementName property value. This 
     * property is described as follows: 
     * 
     * The user-friendly name for this instance of SettingData. In addition, 
     * the user-friendly name can be used as an index property for a search 
     * or query. (Note: The name does not have to be unique within a 
     * namespace.) 
     * 
     * @return	String	current ElementName property value
     * @exception	Exception	
     */
    public String getElementName(){

    return (String)elementName;
    } // getElementName

    /**
     * This method sets the SettingData.ElementName property value. This 
     * property is described as follows: 
     * 
     * The user-friendly name for this instance of SettingData. In addition, 
     * the user-friendly name can be used as an index property for a search 
     * or query. (Note: The name does not have to be unique within a 
     * namespace.) 
     * 
     * @param	String	new ElementName property value
     * @exception	Exception	
     */
    public void setElementName(String elementName) {

    this.elementName = elementName;
    } // setElementName



} // Class SettingData
