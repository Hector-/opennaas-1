/**
 * This file was auto-generated by mofcomp -j version 1.0.0 on Mon Nov 29 
 * 11:50:57 CET 2010. 
 */

package net.i2cat.mantychore.model;

import java.io.Serializable;

/**
 * This Class contains accessor and mutator methods for all properties defined in the CIM class NetworkPipe as well as methods comparable to the
 * invokeMethods defined for this class. This Class implements the NetworkPipeBean Interface. The CIM class NetworkPipe is described as follows:
 * 
 * NetworkPipe is a subclass of EnabledLogicalElement, representing the state and management of a connection or trail between endpoints. This object
 * is different than the association between the endpoints (CIM_ActiveConnection) since the emphasis is NOT on the endpoints but on the management of
 * the pipe itself - its state, configuration, etc. NetworkPipes are defined in the context of a CIM_Network and represent the 'transfer of
 * information . . . between . . . endpoints'. These concepts are aligned with the definition of the Pipe object in ITU's M.3100 specification.
 */
public class NetworkPipe extends EnabledLogicalElement implements Serializable {

	/**
	 * This constructor creates a NetworkPipeBeanImpl Class which implements the NetworkPipeBean Interface, and encapsulates the CIM class NetworkPipe
	 * in a Java Bean. The CIM class NetworkPipe is described as follows:
	 * 
	 * NetworkPipe is a subclass of EnabledLogicalElement, representing the state and management of a connection or trail between endpoints. This
	 * object is different than the association between the endpoints (CIM_ActiveConnection) since the emphasis is NOT on the endpoints but on the
	 * management of the pipe itself - its state, configuration, etc. NetworkPipes are defined in the context of a CIM_Network and represent the
	 * 'transfer of information . . . between . . . endpoints'. These concepts are aligned with the definition of the Pipe object in ITU's M.3100
	 * specification.
	 */
	public NetworkPipe() {
	};

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property InstanceID.
	 */
	private String	instanceID;

	/**
	 * This method returns the NetworkPipe.InstanceID property value. This property is described as follows:
	 * 
	 * Within the scope of the instantiating Namespace, InstanceID opaquely and uniquely identifies an instance of this class. In order to ensure
	 * uniqueness within the NameSpace, the value of InstanceID SHOULD be constructed using the following 'preferred' algorithm: <OrgID>:<LocalID>
	 * Where <OrgID> and <LocalID> are separated by a colon ':', and where <OrgID> MUST include a copyrighted, trademarked or otherwise unique name
	 * that is owned by the business entity creating/defining the InstanceID, or is a registered ID that is assigned to the business entity by a
	 * recognized global authority. (This is similar to the <Schema Name>_<Class Name> structure of Schema class names.) In addition, to ensure
	 * uniqueness <OrgID> MUST NOT contain a colon (':'). When using this algorithm, the first colon to appear in InstanceID MUST appear between
	 * <OrgID> and <LocalID>. (For DMTF defined instances, the 'preferred' algorithm MUST be used with the <OrgID> set to 'CIM'.) <LocalID> MUST
	 * include either a vendor specified unique identifier, or if mapping from an ITU M.3100 environment, the trailID, connectionID or
	 * subNetworkConnectionID of the instances of PipeR2.
	 * 
	 * @return String current InstanceID property value
	 * @exception Exception
	 */
	public String getInstanceID() {

		return (String) instanceID;
	} // getInstanceID

	/**
	 * This method sets the NetworkPipe.InstanceID property value. This property is described as follows:
	 * 
	 * Within the scope of the instantiating Namespace, InstanceID opaquely and uniquely identifies an instance of this class. In order to ensure
	 * uniqueness within the NameSpace, the value of InstanceID SHOULD be constructed using the following 'preferred' algorithm: <OrgID>:<LocalID>
	 * Where <OrgID> and <LocalID> are separated by a colon ':', and where <OrgID> MUST include a copyrighted, trademarked or otherwise unique name
	 * that is owned by the business entity creating/defining the InstanceID, or is a registered ID that is assigned to the business entity by a
	 * recognized global authority. (This is similar to the <Schema Name>_<Class Name> structure of Schema class names.) In addition, to ensure
	 * uniqueness <OrgID> MUST NOT contain a colon (':'). When using this algorithm, the first colon to appear in InstanceID MUST appear between
	 * <OrgID> and <LocalID>. (For DMTF defined instances, the 'preferred' algorithm MUST be used with the <OrgID> set to 'CIM'.) <LocalID> MUST
	 * include either a vendor specified unique identifier, or if mapping from an ITU M.3100 environment, the trailID, connectionID or
	 * subNetworkConnectionID of the instances of PipeR2.
	 * 
	 * @param String
	 *            new InstanceID property value
	 * @exception Exception
	 */
	public void setInstanceID(String instanceID) {

		this.instanceID = instanceID;
	} // setInstanceID

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property Directionality.
	 */

	// public enum Directionality {
	// UNKNOWN,
	// BI_DIRECTIONAL,
	// UNIDIRECTIONAL
	// }
	//
	// Directionality directionality;
	//
	// /**
	// * This method returns the NetworkPipe.Directionality property value. This property is described as follows:
	// *
	// * Indicates whether the pipe is bi-directional (value = 2), unidirectional (value = 3), or this information is not known (value = 0). For
	// * unidirectional pipes, the source and sink are indicated by a property (SourceOrSink) of the association, EndpointOfNetworkPipe.
	// *
	// * @return short current Directionality property value
	// * @exception Exception
	// */
	// public Directionality getDirectionality() {
	//
	// return this.directionality;
	// } // getDirectionality
	//
	// /**
	// * This method sets the NetworkPipe.Directionality property value. This property is described as follows:
	// *
	// * Indicates whether the pipe is bi-directional (value = 2), unidirectional (value = 3), or this information is not known (value = 0). For
	// * unidirectional pipes, the source and sink are indicated by a property (SourceOrSink) of the association, EndpointOfNetworkPipe.
	// *
	// * @param short new Directionality property value
	// * @exception Exception
	// */
	// public void setDirectionality(Directionality directionality) {
	//
	// this.directionality = directionality;
	// } // setDirectionality

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property AggregationBehavior.
	 */

	public enum AggregationBehavior {
		UNKNOWN,
		NO_LOWER_LEVEL_COMPOSITION,
		COMBINED_IN_PARALLEL,
		COMBINED_IN_SEQUENCE
	}

	AggregationBehavior	aggregationBehavior;

	/**
	 * This method returns the NetworkPipe.AggregationBehavior property value. This property is described as follows:
	 * 
	 * Indicates whether the pipe is composed of lower-level pipes, and if so, how these lower-level pipes are aggregated (in parallel or in
	 * sequence). The specific instances of NetworkPipe that are combined are described using the NetworkPipeComposition association. In the context
	 * of M.3100, the ability to be composed of lower-level pipes is modeled as a Trail. A Trail is made up of one or more Connections. (Note that
	 * both Trails and Connections are subclasses of Pipe). Because of the flexibility of the NetworkPipeComposition association, there is no need to
	 * subclass NetworkPipe, as was done in M.3100, but merely to instantiate the NetworkPipeComposition association to describe the bundling of the
	 * lower-level pipes (i.e., the connections), or the sequencing of them.
	 * 
	 * @return short current AggregationBehavior property value
	 * @exception Exception
	 */
	public AggregationBehavior getAggregationBehavior() {

		return this.aggregationBehavior;
	} // getAggregationBehavior

	/**
	 * This method sets the NetworkPipe.AggregationBehavior property value. This property is described as follows:
	 * 
	 * Indicates whether the pipe is composed of lower-level pipes, and if so, how these lower-level pipes are aggregated (in parallel or in
	 * sequence). The specific instances of NetworkPipe that are combined are described using the NetworkPipeComposition association. In the context
	 * of M.3100, the ability to be composed of lower-level pipes is modeled as a Trail. A Trail is made up of one or more Connections. (Note that
	 * both Trails and Connections are subclasses of Pipe). Because of the flexibility of the NetworkPipeComposition association, there is no need to
	 * subclass NetworkPipe, as was done in M.3100, but merely to instantiate the NetworkPipeComposition association to describe the bundling of the
	 * lower-level pipes (i.e., the connections), or the sequencing of them.
	 * 
	 * @param short new AggregationBehavior property value
	 * @exception Exception
	 */
	public void setAggregationBehavior(AggregationBehavior
			aggregationBehavior) {

		this.aggregationBehavior = aggregationBehavior;
	} // setAggregationBehavior

	/**
	 * The following constants are defined for use with the ValueMap/Values qualified property EnabledState.
	 */

	public enum EnabledState {
		UNKNOWN,
		OTHER,
		ENABLED,
		DISABLED,
		SHUTTING_DOWN,
		NOT_APPLICABLE,
		ENABLED_BUT_OFFLINE,
		IN_TEST,
		DEFERRED,
		QUIESCE,
		STARTING,
		DMTF_RESERVED,
		VENDOR_RESERVED
	}

	EnabledState	enabledState;

	/**
	 * This method returns the NetworkPipe.EnabledState property value. This property is described as follows:
	 * 
	 * EnabledState is an integer enumeration that indicates the enabled and disabled states of an element. It can also indicate the transitions
	 * between these requested states. For example, shutting down (value=4) and starting (value=10) are transient states between enabled and disabled.
	 * The following text briefly summarizes the various enabled and disabled states: Enabled (2) indicates that the element is or could be executing
	 * commands, will process any queued commands, and queues new requests. Disabled (3) indicates that the element will not execute commands and will
	 * drop any new requests. Shutting Down (4) indicates that the element is in the process of going to a Disabled state. Not Applicable (5)
	 * indicates the element does not support being enabled or disabled. Enabled but Offline (6) indicates that the element might be completing
	 * commands, and will drop any new requests. Test (7) indicates that the element is in a test state. Deferred (8) indicates that the element might
	 * be completing commands, but will queue any new requests. Quiesce (9) indicates that the element is enabled but in a restricted mode. Starting
	 * (10) indicates that the element is in the process of going to an Enabled state. New requests are queued.
	 * 
	 * @return short current EnabledState property value
	 * @exception Exception
	 */
	public EnabledState getEnabledState() {

		return this.enabledState;
	} // getEnabledState

	/**
	 * This method sets the NetworkPipe.EnabledState property value. This property is described as follows:
	 * 
	 * EnabledState is an integer enumeration that indicates the enabled and disabled states of an element. It can also indicate the transitions
	 * between these requested states. For example, shutting down (value=4) and starting (value=10) are transient states between enabled and disabled.
	 * The following text briefly summarizes the various enabled and disabled states: Enabled (2) indicates that the element is or could be executing
	 * commands, will process any queued commands, and queues new requests. Disabled (3) indicates that the element will not execute commands and will
	 * drop any new requests. Shutting Down (4) indicates that the element is in the process of going to a Disabled state. Not Applicable (5)
	 * indicates the element does not support being enabled or disabled. Enabled but Offline (6) indicates that the element might be completing
	 * commands, and will drop any new requests. Test (7) indicates that the element is in a test state. Deferred (8) indicates that the element might
	 * be completing commands, but will queue any new requests. Quiesce (9) indicates that the element is enabled but in a restricted mode. Starting
	 * (10) indicates that the element is in the process of going to an Enabled state. New requests are queued.
	 * 
	 * @param short new EnabledState property value
	 * @exception Exception
	 */
	public void setEnabledState(EnabledState enabledState) {

		this.enabledState = enabledState;
	} // setEnabledState

	// /**
	// * The following constants are defined for use with the ValueMap/Values qualified property RequestedState.
	// */
	//
	// public enum RequestedState {
	// UNKNOWN,
	// ENABLED,
	// DISABLED,
	// SHUT_DOWN,
	// NO_CHANGE,
	// OFFLINE,
	// TEST,
	// DEFERRED,
	// QUIESCE,
	// REBOOT,
	// RESET,
	// NOT_APPLICABLE,
	// DMTF_RESERVED,
	// VENDOR_RESERVED
	// }
	//
	// RequestedState requestedState;

	/**
	 * This method returns the NetworkPipe.RequestedState property value. This property is described as follows:
	 * 
	 * RequestedState is an integer enumeration that indicates the last requested or desired state for the element, irrespective of the mechanism
	 * through which it was requested. The actual state of the element is represented by EnabledState. This property is provided to compare the last
	 * requested and current enabled or disabled states. Note that when EnabledState is set to 5 ("Not Applicable"), then this property has no
	 * meaning. Refer to the EnabledState property description for explanations of the values in the RequestedState enumeration. "Unknown" (0)
	 * indicates the last requested state for the element is unknown. Note that the value "No Change" (5) has been deprecated in lieu of indicating
	 * the last requested state is "Unknown" (0). If the last requested or desired state is unknown, RequestedState should have the value "Unknown"
	 * (0), but may have the value "No Change" (5).Offline (6) indicates that the element has been requested to transition to the Enabled but Offline
	 * EnabledState. It should be noted that there are two new values in RequestedState that build on the statuses of EnabledState. These are "Reboot"
	 * (10) and "Reset" (11). Reboot refers to doing a "Shut Down" and then moving to an "Enabled" state. Reset indicates that the element is first
	 * "Disabled" and then "Enabled". The distinction between requesting "Shut Down" and "Disabled" should also be noted. Shut Down requests an
	 * orderly transition to the Disabled state, and might involve removing power, to completely erase any existing state. The Disabled state requests
	 * an immediate disabling of the element, such that it will not execute or accept any commands or processing requests. This property is set as the
	 * result of a method invocation (such as Start or StopService on CIM_Service), or can be overridden and defined as WRITEable in a subclass. The
	 * method approach is considered superior to a WRITEable property, because it allows an explicit invocation of the operation and the return of a
	 * result code. If knowledge of the last RequestedState is not supported for the EnabledLogicalElement, the property shall be NULL or have the
	 * value 12 "Not Applicable".
	 * 
	 * @return short current RequestedState property value
	 * @exception Exception
	 */
	public RequestedState getRequestedState() {

		return this.requestedState;
	} // getRequestedState

	/**
	 * This method sets the NetworkPipe.RequestedState property value. This property is described as follows:
	 * 
	 * RequestedState is an integer enumeration that indicates the last requested or desired state for the element, irrespective of the mechanism
	 * through which it was requested. The actual state of the element is represented by EnabledState. This property is provided to compare the last
	 * requested and current enabled or disabled states. Note that when EnabledState is set to 5 ("Not Applicable"), then this property has no
	 * meaning. Refer to the EnabledState property description for explanations of the values in the RequestedState enumeration. "Unknown" (0)
	 * indicates the last requested state for the element is unknown. Note that the value "No Change" (5) has been deprecated in lieu of indicating
	 * the last requested state is "Unknown" (0). If the last requested or desired state is unknown, RequestedState should have the value "Unknown"
	 * (0), but may have the value "No Change" (5).Offline (6) indicates that the element has been requested to transition to the Enabled but Offline
	 * EnabledState. It should be noted that there are two new values in RequestedState that build on the statuses of EnabledState. These are "Reboot"
	 * (10) and "Reset" (11). Reboot refers to doing a "Shut Down" and then moving to an "Enabled" state. Reset indicates that the element is first
	 * "Disabled" and then "Enabled". The distinction between requesting "Shut Down" and "Disabled" should also be noted. Shut Down requests an
	 * orderly transition to the Disabled state, and might involve removing power, to completely erase any existing state. The Disabled state requests
	 * an immediate disabling of the element, such that it will not execute or accept any commands or processing requests. This property is set as the
	 * result of a method invocation (such as Start or StopService on CIM_Service), or can be overridden and defined as WRITEable in a subclass. The
	 * method approach is considered superior to a WRITEable property, because it allows an explicit invocation of the operation and the return of a
	 * result code. If knowledge of the last RequestedState is not supported for the EnabledLogicalElement, the property shall be NULL or have the
	 * value 12 "Not Applicable".
	 * 
	 * @param short new RequestedState property value
	 * @exception Exception
	 */
	public void setRequestedState(RequestedState requestedState) {

		this.requestedState = requestedState;
	} // setRequestedState

} // Class NetworkPipe
