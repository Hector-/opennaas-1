/**
 * This file was auto-generated by mofcomp -j version 1.0.0 on Mon Jan 03 
 * 16:22:03 CET 2011. 
 */

package net.i2cat.mantychore.model;

import java.util.*;
import java.io.*;
import javax.persistence.*;
import java.lang.Exception;

/**
 * This Class contains accessor and mutator methods for all properties defined 
 * in the CIM class BasedOn as well as methods comparable to the 
 * invokeMethods defined for this class. This Class implements the 
 * BasedOnBean Interface. The CIM class BasedOn is described as follows: 
 * 
 * BasedOn is an association describing how StorageExtents can be assembled 
 * from lower level Extents. For example, ProtectedSpaceExtents are parts of 
 * PhysicalExtents, while VolumeSets are assembled from one or more Physical 
 * or ProtectedSpaceExtents. As another example, CacheMemory can be defined 
 * independently and realized in a PhysicalElement or can be 'based on' 
 * Volatile or NonVolatileStorageExtents. 
 */
    @Entity
public class BasedOn extends Dependency implements Serializable {

    /**
     * This constructor creates a BasedOnBeanImpl Class which implements the 
     * BasedOnBean Interface, and encapsulates the CIM class BasedOn in a 
     * Java Bean. The CIM class BasedOn is described as follows: 
     * 
     * BasedOn is an association describing how StorageExtents can be 
     * assembled from lower level Extents. For example, ProtectedSpaceExtents 
     * are parts of PhysicalExtents, while VolumeSets are assembled from one 
     * or more Physical or ProtectedSpaceExtents. As another example, 
     * CacheMemory can be defined independently and realized in a 
     * PhysicalElement or can be 'based on' Volatile or 
     * NonVolatileStorageExtents. 
     */
    public BasedOn(){};
    /**
     * This method create an Association of the type BasedOn between one 
     * StorageExtent object and StorageExtent object 
     */
    public Association link(StorageExtent antecedent,StorageExtent 
	dependent){

    return super.link(BasedOn.class,antecedent,dependent);
    }//link
    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property StartingAddress. 
     */
    private long startingAddress;
    /**
     * This method returns the BasedOn.startingAddress property value. This 
     * property is described as follows: 
     * 
     * StartingAddress indicates where in lower level storage, the higher 
     * level Extent begins. 
     * 
     * @return	long	current startingAddress property value
     * @exception	Exception	
     */
    public long getstartingAddress(){

    return this.startingAddress;
    } // getstartingAddress

    /**
     * This method sets the BasedOn.startingAddress property value. This 
     * property is described as follows: 
     * 
     * StartingAddress indicates where in lower level storage, the higher 
     * level Extent begins. 
     * 
     * @param	long	new startingAddress property value
     * @exception	Exception	
     */
    public void setstartingAddress(long startingAddress) {

    this.startingAddress = startingAddress;
    } // setstartingAddress


    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property EndingAddress. 
     */
    private long endingAddress;
    /**
     * This method returns the BasedOn.endingAddress property value. This 
     * property is described as follows: 
     * 
     * EndingAddress indicates where in lower level storage, the higher level 
     * Extent ends. This property is useful when mapping non-contiguous 
     * Extents into a higher level grouping. 
     * 
     * @return	long	current endingAddress property value
     * @exception	Exception	
     */
    public long getendingAddress(){

    return this.endingAddress;
    } // getendingAddress

    /**
     * This method sets the BasedOn.endingAddress property value. This 
     * property is described as follows: 
     * 
     * EndingAddress indicates where in lower level storage, the higher level 
     * Extent ends. This property is useful when mapping non-contiguous 
     * Extents into a higher level grouping. 
     * 
     * @param	long	new endingAddress property value
     * @exception	Exception	
     */
    public void setendingAddress(long endingAddress) {

    this.endingAddress = endingAddress;
    } // setendingAddress


    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property OrderIndex. 
     */
    private int orderIndex;
    /**
     * This method returns the BasedOn.orderIndex property value. This 
     * property is described as follows: 
     * 
     * If there is an order to the BasedOn associations that describe how a 
     * higher level StorageExtent is assembled, the OrderIndex property 
     * indicates this. When an order exists, the instances of BasedOn with 
     * the same Dependent value (i.e., the same higher level Extent) should 
     * place unique values in the OrderIndex property. The lowest value 
     * implies the first member of the collection of lower level Extents, and 
     * increasing values imply successive members of the collection. If there 
     * is no ordered relationship, a value of zero should be specified. An 
     * example of the use of this property is to define a RAID-0 striped 
     * array of 3 disks. The resultant RAID array is a StorageExtent that is 
     * dependent on (BasedOn) the StorageExtents that describe each of the 3 
     * disks. The OrderIndex of each BasedOn association from the disk 
     * Extents to the RAID array could be specified as 1, 2 and 3 to indicate 
     * the order in which the disk Extents are used to access the RAID data. 
     * 
     * @return	int	current orderIndex property value
     * @exception	Exception	
     */
    public int getorderIndex(){

    return this.orderIndex;
    } // getorderIndex

    /**
     * This method sets the BasedOn.orderIndex property value. This property 
     * is described as follows: 
     * 
     * If there is an order to the BasedOn associations that describe how a 
     * higher level StorageExtent is assembled, the OrderIndex property 
     * indicates this. When an order exists, the instances of BasedOn with 
     * the same Dependent value (i.e., the same higher level Extent) should 
     * place unique values in the OrderIndex property. The lowest value 
     * implies the first member of the collection of lower level Extents, and 
     * increasing values imply successive members of the collection. If there 
     * is no ordered relationship, a value of zero should be specified. An 
     * example of the use of this property is to define a RAID-0 striped 
     * array of 3 disks. The resultant RAID array is a StorageExtent that is 
     * dependent on (BasedOn) the StorageExtents that describe each of the 3 
     * disks. The OrderIndex of each BasedOn association from the disk 
     * Extents to the RAID array could be specified as 1, 2 and 3 to indicate 
     * the order in which the disk Extents are used to access the RAID data. 
     * 
     * @param	int	new orderIndex property value
     * @exception	Exception	
     */
    public void setorderIndex(int orderIndex) {

    this.orderIndex = orderIndex;
    } // setorderIndex



} // Class BasedOn
