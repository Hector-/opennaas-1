/**
 * This file was auto-generated by mofcomp -j version 1.0.0 on Mon Nov 29 
 * 11:50:57 CET 2010. 
 */

package net.i2cat.mantychore.model;

import javax.wbem.client.*;
import javax.wbem.cim.*;
import java.util.*;
import java.io.*;
import java.lang.Exception;

/**
 * This Class contains accessor and mutator methods for all properties defined 
 * in the CIM class ResourcePool as well as methods comparable to the 
 * invokeMethods defined for this class. This Class implements the 
 * ResourcePoolBean Interface. The CIM class ResourcePool is described as 
 * follows: 
 * 
 * A ResourcePool is a logical entity (with associated controls)provided by 
 * the host system for the purpose of allocation and assignment of resources. 
 * A given ResourcePool may be used to allocate resources of a specific type. 
 * Hierarchies of ResourcePools may be created to provide administrative 
 * control over allocations. In the cases where resources are subdivided, 
 * multiple resource pools may exist (e.g. nodal boundaries in NUMA-like 
 * systems). In systems that support over commitment, pools represent the 
 * reservable capacity, not an upper bound or limit on the maximum amount 
 * that can be allocated. Admission control during power on may detect and 
 * prevent systems from powering due to resource exhaustion. For example, 
 * over commitment on a ResourcePool with ResourceType=Memory would require 
 * that sufficient space be available in some backing-store, that may be 
 * managed through a storage ResourcePool. 
 */
public class ResourcePool extends LogicalElement implements Serializable {

    /**
     * This constructor creates a ResourcePoolBeanImpl Class which implements 
     * the ResourcePoolBean Interface, and encapsulates the CIM class 
     * ResourcePool in a Java Bean. The CIM class ResourcePool is described 
     * as follows: 
     * 
     * A ResourcePool is a logical entity (with associated controls)provided 
     * by the host system for the purpose of allocation and assignment of 
     * resources. A given ResourcePool may be used to allocate resources of a 
     * specific type. Hierarchies of ResourcePools may be created to provide 
     * administrative control over allocations. In the cases where resources 
     * are subdivided, multiple resource pools may exist (e.g. nodal 
     * boundaries in NUMA-like systems). In systems that support over 
     * commitment, pools represent the reservable capacity, not an upper 
     * bound or limit on the maximum amount that can be allocated. Admission 
     * control during power on may detect and prevent systems from powering 
     * due to resource exhaustion. For example, over commitment on a 
     * ResourcePool with ResourceType=Memory would require that sufficient 
     * space be available in some backing-store, that may be managed through 
     * a storage ResourcePool. 
     */
    public ResourcePool(){};
    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property InstanceID. 
     */
    private String instanceID;
    /**
     * This method returns the ResourcePool.InstanceID property value. This 
     * property is described as follows: 
     * 
     * Within the scope of the instantiating Namespace, InstanceID opaquely 
     * and uniquely identifies an instance of this class. To ensure 
     * uniqueness within the NameSpace, the value of InstanceID should be 
     * constructed using the following "preferred" algorithm: 
     * <OrgID>:<LocalID> Where <OrgID> and <LocalID> are separated by a colon 
     * (:), and where <OrgID> must include a copyrighted, trademarked, or 
     * otherwise unique name that is owned by the business entity that is 
     * creating or defining the InstanceID or that is a registered ID 
     * assigned to the business entity by a recognized global authority. 
     * (This requirement is similar to the <Schema Name>_<Class Name> 
     * structure of Schema class names.) In addition, to ensure uniqueness, 
     * <OrgID> must not contain a colon (:). When using this algorithm, the 
     * first colon to appear in InstanceID must appear between <OrgID> and 
     * <LocalID>. <LocalID> is chosen by the business entity and should not 
     * be reused to identify different underlying (real-world) elements. If 
     * the above "preferred" algorithm is not used, the defining entity must 
     * ensure that the resulting InstanceID is not reused across any 
     * InstanceIDs produced by this or other providers for the NameSpace of 
     * this instance. For DMTF-defined instances, the "preferred" algorithm 
     * must be used with the <OrgID> set to CIM. 
     * 
     * @return	String	current InstanceID property value
     * @exception	Exception	
     */
    public String getInstanceID(){

    return (String)instanceID;
    } // getInstanceID

    /**
     * This method sets the ResourcePool.InstanceID property value. This 
     * property is described as follows: 
     * 
     * Within the scope of the instantiating Namespace, InstanceID opaquely 
     * and uniquely identifies an instance of this class. To ensure 
     * uniqueness within the NameSpace, the value of InstanceID should be 
     * constructed using the following "preferred" algorithm: 
     * <OrgID>:<LocalID> Where <OrgID> and <LocalID> are separated by a colon 
     * (:), and where <OrgID> must include a copyrighted, trademarked, or 
     * otherwise unique name that is owned by the business entity that is 
     * creating or defining the InstanceID or that is a registered ID 
     * assigned to the business entity by a recognized global authority. 
     * (This requirement is similar to the <Schema Name>_<Class Name> 
     * structure of Schema class names.) In addition, to ensure uniqueness, 
     * <OrgID> must not contain a colon (:). When using this algorithm, the 
     * first colon to appear in InstanceID must appear between <OrgID> and 
     * <LocalID>. <LocalID> is chosen by the business entity and should not 
     * be reused to identify different underlying (real-world) elements. If 
     * the above "preferred" algorithm is not used, the defining entity must 
     * ensure that the resulting InstanceID is not reused across any 
     * InstanceIDs produced by this or other providers for the NameSpace of 
     * this instance. For DMTF-defined instances, the "preferred" algorithm 
     * must be used with the <OrgID> set to CIM. 
     * 
     * @param	String	new InstanceID property value
     * @exception	Exception	
     */
    public void setInstanceID(String instanceID) {

    this.instanceID = instanceID;
    } // setInstanceID


    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property PoolID. 
     */
    private String poolID;
    /**
     * This method returns the ResourcePool.PoolID property value. This 
     * property is described as follows: 
     * 
     * An opaque identifier for the pool. This property is used to provide 
     * correlation across save and restore of configuration data to 
     * underlying persistent storage. 
     * 
     * @return	String	current PoolID property value
     * @exception	Exception	
     */
    public String getPoolID(){

    return this.poolID;
    } // getPoolID

    /**
     * This method sets the ResourcePool.PoolID property value. This property 
     * is described as follows: 
     * 
     * An opaque identifier for the pool. This property is used to provide 
     * correlation across save and restore of configuration data to 
     * underlying persistent storage. 
     * 
     * @param	String	new PoolID property value
     * @exception	Exception	
     */
    public void setPoolID(String poolID) {

    this.poolID = poolID;
    } // setPoolID


    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property Primordial. 
     */
    private boolean primordial;
    /**
     * This method returns the ResourcePool.Primordial property value. This 
     * property is described as follows: 
     * 
     * If true, "Primordial" indicates that this ResourcePool is a base from 
     * which resources are drawn and returned in the activity of resource 
     * management. Being primordial means that this ResourcePool shall not be 
     * created or deleted by consumers of this model. However, other actions, 
     * modeled or not, may affect the characteristics or size of primordial 
     * ResourcePools. If false, "Primordial" indicates that the ResourcePool, 
     * a concrete Resource Pool, is subject to resource allocation services 
     * functions. This distinction is important because higher-level 
     * ResourcePools may be assembled using the Component or 
     * ElementAllocatedFromPool associations. Although the higher-level 
     * abstractions can be created and deleted, the most basic, (i.e. 
     * primordial), hardware-based ResourcePools cannot. They are physically 
     * realized as part of the System, or are actually managed by some other 
     * System and imported as if they were physically realized. 
     * 
     * @return	boolean	current Primordial property value
     * @exception	Exception	
     */
    public boolean isPrimordial(){

    return this.primordial;
    } // getPrimordial

    /**
     * This method sets the ResourcePool.Primordial property value. This 
     * property is described as follows: 
     * 
     * If true, "Primordial" indicates that this ResourcePool is a base from 
     * which resources are drawn and returned in the activity of resource 
     * management. Being primordial means that this ResourcePool shall not be 
     * created or deleted by consumers of this model. However, other actions, 
     * modeled or not, may affect the characteristics or size of primordial 
     * ResourcePools. If false, "Primordial" indicates that the ResourcePool, 
     * a concrete Resource Pool, is subject to resource allocation services 
     * functions. This distinction is important because higher-level 
     * ResourcePools may be assembled using the Component or 
     * ElementAllocatedFromPool associations. Although the higher-level 
     * abstractions can be created and deleted, the most basic, (i.e. 
     * primordial), hardware-based ResourcePools cannot. They are physically 
     * realized as part of the System, or are actually managed by some other 
     * System and imported as if they were physically realized. 
     * 
     * @param	boolean	new Primordial property value
     * @exception	Exception	
     */
    public void setPrimordial(boolean primordial) {

    this.primordial = primordial;
    } // setPrimordial


    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property Capacity. 
     */
    private long capacity;
    /**
     * This method returns the ResourcePool.Capacity property value. This 
     * property is described as follows: 
     * 
     * This property represents the maximum amount (in units of 
     * AllocationUnits) of reservations that the ResourcePool can support. 
     * 
     * @return	long	current Capacity property value
     * @exception	Exception	
     */
    public long getCapacity(){

    return this.capacity;
    } // getCapacity

    /**
     * This method sets the ResourcePool.Capacity property value. This 
     * property is described as follows: 
     * 
     * This property represents the maximum amount (in units of 
     * AllocationUnits) of reservations that the ResourcePool can support. 
     * 
     * @param	long	new Capacity property value
     * @exception	Exception	
     */
    public void setCapacity(long capacity) {

    this.capacity = capacity;
    } // setCapacity


    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property Reserved. 
     */
    private long reserved;
    /**
     * This method returns the ResourcePool.Reserved property value. This 
     * property is described as follows: 
     * 
     * This property represents the current reservations (in units of 
     * AllocationUnits) spread across all active allocations from this pool. 
     * In a hierarchical configuration, this represents the sum of all 
     * descendant ResourcePool current reservations. 
     * 
     * @return	long	current Reserved property value
     * @exception	Exception	
     */
    public long getReserved(){

    return this.reserved;
    } // getReserved

    /**
     * This method sets the ResourcePool.Reserved property value. This 
     * property is described as follows: 
     * 
     * This property represents the current reservations (in units of 
     * AllocationUnits) spread across all active allocations from this pool. 
     * In a hierarchical configuration, this represents the sum of all 
     * descendant ResourcePool current reservations. 
     * 
     * @param	long	new Reserved property value
     * @exception	Exception	
     */
    public void setReserved(long reserved) {

    this.reserved = reserved;
    } // setReserved


    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property ResourceType. 
     */

    public enum ResourceType{
    OTHER,
    COMPUTER_SYSTEM,
    PROCESSOR,
    MEMORY,
    IDE_CONTROLLER,
    PARALLEL_SCSI_HBA,
    FC_HBA,
    ISCSI_HBA,
    IB_HCA,
    ETHERNET_ADAPTER,
    OTHER_NETWORK_ADAPTER,
    I_O_SLOT,
    I_O_DEVICE,
    FLOPPY_DRIVE,
    CD_DRIVE,
    DVD_DRIVE,
    DISK_DRIVE,
    TAPE_DRIVE,
    STORAGE_EXTENT,
    OTHER_STORAGE_DEVICE,
    SERIAL_PORT,
    PARALLEL_PORT,
    USB_CONTROLLER,
    GRAPHICS_CONTROLLER,
    IEEE_1394_CONTROLLER,
    PARTITIONABLE_UNIT,
    BASE_PARTITIONABLE_UNIT,
    POWER,
    COOLING_CAPACITY,
    ETHERNET_SWITCH_PORT,
    LOGICAL_DISK,
    STORAGE_VOLUME,
    ETHERNET_CONNECTION,
    DMTF_RESERVED,
    VENDOR_RESERVED
    }ResourceType resourceType;
    /**
     * This method returns the ResourcePool.ResourceType property value. This 
     * property is described as follows: 
     * 
     * The type of resource this ResourcePool may allocate.
     * 
     * @return	short	current ResourceType property value
     * @exception	Exception	
     */
    public ResourceType getResourceType(){

    return this.resourceType;
    } // getResourceType

    /**
     * This method sets the ResourcePool.ResourceType property value. This 
     * property is described as follows: 
     * 
     * The type of resource this ResourcePool may allocate.
     * 
     * @param	short	new ResourceType property value
     * @exception	Exception	
     */
    public void setResourceType(ResourceType resourceType){

    this.resourceType = resourceType;
    } // setResourceType


    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property OtherResourceType. 
     */
    private String otherResourceType;
    /**
     * This method returns the ResourcePool.OtherResourceType property value. 
     * This property is described as follows: 
     * 
     * A string that describes the resource type when a well defined value is 
     * not available and ResourceType is set to 0 for Other. 
     * 
     * @return	String	current OtherResourceType property value
     * @exception	Exception	
     */
    public String getOtherResourceType(){

    return this.otherResourceType;
    } // getOtherResourceType

    /**
     * This method sets the ResourcePool.OtherResourceType property value. 
     * This property is described as follows: 
     * 
     * A string that describes the resource type when a well defined value is 
     * not available and ResourceType is set to 0 for Other. 
     * 
     * @param	String	new OtherResourceType property value
     * @exception	Exception	
     */
    public void setOtherResourceType(String otherResourceType) {

    this.otherResourceType = otherResourceType;
    } // setOtherResourceType


    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property ResourceSubType. 
     */
    private String resourceSubType;
    /**
     * This method returns the ResourcePool.ResourceSubType property value. 
     * This property is described as follows: 
     * 
     * A string describing an implementation specific sub-type for this pool. 
     * For example, this may be used to distinguish different models of the 
     * same resource type. 
     * 
     * @return	String	current ResourceSubType property value
     * @exception	Exception	
     */
    public String getResourceSubType(){

    return this.resourceSubType;
    } // getResourceSubType

    /**
     * This method sets the ResourcePool.ResourceSubType property value. This 
     * property is described as follows: 
     * 
     * A string describing an implementation specific sub-type for this pool. 
     * For example, this may be used to distinguish different models of the 
     * same resource type. 
     * 
     * @param	String	new ResourceSubType property value
     * @exception	Exception	
     */
    public void setResourceSubType(String resourceSubType) {

    this.resourceSubType = resourceSubType;
    } // setResourceSubType


    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property AllocationUnits. 
     */
    private String allocationUnits;
    /**
     * This method returns the ResourcePool.AllocationUnits property value. 
     * This property is described as follows: 
     * 
     * This property specifies the units of allocation used by the Reservation 
     * and Limit properties. For example, when ResourceType=Processor, 
     * AllocationUnits may be set to hertz*10^6 or percent. When 
     * ResourceType=Memory, AllocationUnits may be set to bytes*10^3. The 
     * value of this property shall be a legal value of the Programmatic 
     * Units qualifier as defined in Appendix C.1 of DSP0004 V2.4 or later. 
     * 
     * @return	String	current AllocationUnits property value
     * @exception	Exception	
     */
    public String getAllocationUnits(){

    return this.allocationUnits;
    } // getAllocationUnits

    /**
     * This method sets the ResourcePool.AllocationUnits property value. This 
     * property is described as follows: 
     * 
     * This property specifies the units of allocation used by the Reservation 
     * and Limit properties. For example, when ResourceType=Processor, 
     * AllocationUnits may be set to hertz*10^6 or percent. When 
     * ResourceType=Memory, AllocationUnits may be set to bytes*10^3. The 
     * value of this property shall be a legal value of the Programmatic 
     * Units qualifier as defined in Appendix C.1 of DSP0004 V2.4 or later. 
     * 
     * @param	String	new AllocationUnits property value
     * @exception	Exception	
     */
    public void setAllocationUnits(String allocationUnits) {

    this.allocationUnits = allocationUnits;
    } // setAllocationUnits


    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property ConsumedResourceUnits. 
     */
    private String consumedResourceUnits;
    /**
     * This method returns the ResourcePool.ConsumedResourceUnits property 
     * value. This property is described as follows: 
     * 
     * This property specifies the units for the MaxConsumable and the 
     * Consumed properties. 
     * 
     * @return	String	current ConsumedResourceUnits property 
     * value 
     * @exception	Exception	
     */
    public String getConsumedResourceUnits(){

    return this.consumedResourceUnits;
    } // getConsumedResourceUnits

    /**
     * This method sets the ResourcePool.ConsumedResourceUnits property value. 
     * This property is described as follows: 
     * 
     * This property specifies the units for the MaxConsumable and the 
     * Consumed properties. 
     * 
     * @param	String	new ConsumedResourceUnits property value
     * @exception	Exception	
     */
    public void setConsumedResourceUnits(String consumedResourceUnits) {

    this.consumedResourceUnits = consumedResourceUnits;
    } // setConsumedResourceUnits


    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property CurrentlyConsumedResource. 
     */
    private long currentlyConsumedResource;
    /**
     * This method returns the ResourcePool.CurrentlyConsumedResource property 
     * value. This property is described as follows: 
     * 
     * This property specifies the amount of resource that the resource pool 
     * currently presents to consumers. This property is different from the 
     * Reserved property in that it describes the consumers view of the 
     * resource while the Reserved property describes the producers view of 
     * the resource. 
     * 
     * @return	long	current CurrentlyConsumedResource property 
     * value 
     * @exception	Exception	
     */
    public long getCurrentlyConsumedResource(){

    return this.currentlyConsumedResource;
    } // getCurrentlyConsumedResource

    /**
     * This method sets the ResourcePool.CurrentlyConsumedResource property 
     * value. This property is described as follows: 
     * 
     * This property specifies the amount of resource that the resource pool 
     * currently presents to consumers. This property is different from the 
     * Reserved property in that it describes the consumers view of the 
     * resource while the Reserved property describes the producers view of 
     * the resource. 
     * 
     * @param	long	new CurrentlyConsumedResource property value
     * @exception	Exception	
     */
    public void setCurrentlyConsumedResource(long currentlyConsumedResource) 
	{

    this.currentlyConsumedResource = currentlyConsumedResource;
    } // setCurrentlyConsumedResource


    /**
     * The following constants are defined for use with the ValueMap/Values 
     * qualified property MaxConsumableResource. 
     */
    private long maxConsumableResource;
    /**
     * This method returns the ResourcePool.MaxConsumableResource property 
     * value. This property is described as follows: 
     * 
     * This property specifies the maximum of amount of consumable resource 
     * that the resource pool can present to consumers. This property is 
     * different from the Capacity property in that it describes the 
     * consumers view of the resource while the Capacity property describes 
     * the producers view of the resource. 
     * 
     * @return	long	current MaxConsumableResource property value
     * @exception	Exception	
     */
    public long getMaxConsumableResource(){

    return this.maxConsumableResource;
    } // getMaxConsumableResource

    /**
     * This method sets the ResourcePool.MaxConsumableResource property value. 
     * This property is described as follows: 
     * 
     * This property specifies the maximum of amount of consumable resource 
     * that the resource pool can present to consumers. This property is 
     * different from the Capacity property in that it describes the 
     * consumers view of the resource while the Capacity property describes 
     * the producers view of the resource. 
     * 
     * @param	long	new MaxConsumableResource property value
     * @exception	Exception	
     */
    public void setMaxConsumableResource(long maxConsumableResource) {

    this.maxConsumableResource = maxConsumableResource;
    } // setMaxConsumableResource



} // Class ResourcePool
